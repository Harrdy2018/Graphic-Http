# 传输层

# OSI模型和DoD模型
***
![](https://github.com/Harrdy2018/Graphic-Http/blob/master/OSI%20and%20DoD.png)
***
```
DoD(Departemnt of Defense 国防部)模型，也就是TCP/IP模型
TCP(Transmission Control Protocol 传输控制协议)
UDP(User Data Protocol 用户数据报协议)
什么时候使用？
TCP:需要将要传输的文件分段，传输建立会话，可靠传输，流量控制
UDP:一个数据报就能完成通信，不需要建立会话，不需要流量控制，不可靠传输
```

***
```
PDU(Protocol Data Unit 协议数据单元)表示对等层之间传递的数据单位
应用层的PDU---------->>报文(message)
传输层的PDU---------->>数据段(segment)
网络层的PDU---------->>数据包(packet)
数据链路层的PDU------>>数据帧(frame)
物理层的PDU---------->>数据位(bit)
```

***
**IP分组的最大字节数是65535字节还是65536字节？？**
```
2^(16)=65536    
区间为0~65535字节
数据包的最大长度的字段是16位，那么这16位所能表示的最大数字就是(2^16-1)，
二进制就是16个1排起来，所以数据包的最大长度就是65535
```

***
# IPv4数据包格式
***
![](https://github.com/Harrdy2018/Graphic-Http/blob/master/IPv4%20packet.png)
***
* **一个IP数据报由首部和数据两部分组成**
* **首部的前一部分是固定长度，一共是32bit`*`5=160bit=20字节，所以我们常说固定首部长度为20字节**
* **在首部的固定部分的后面是一些可选字段，其长度是可变的**
* 一、版本(Version):长度4bit,标识目前采用的 IP 协议的版本号。一般的值为 0100（IPv4),0110（IPv6）
***
|版本号|版本|RFC文档|
|:-----|:-----|:-----|
|0|保留||
|1~3|未分配||
|4|Internet 协议版本 4（IPv4）|RFC791|
|5|ST 数据报（Datagram）|RFC1190|
|6|IPv6|RFC1883|
|7|TP / IX|	RFC1475|
|8|P Internet 协议（PIP）|RFC1621|
|9|使用更大地址的 TCP 和 UDP（TUBA）|RFC1347|
|10~14|未分配||
|15|保留||
***

* 二、首部长度(Header Length):长度 4 bit 。这个字段的作用是为了描述 IP 报头的长度，因为在 IP 报头中有变长的可选部分。
```
该部分占4bit,可表示的最大数值是15个单位(一个单位为4字节)，
即本区域值 = IP 头部长度（单位为字节）/ 长度单位（4 个字节）。
因此，一个 IP 报头的长度最长为 “ 1111 ”，即 15 x 4 个字节 = 60 个字节。
IP 报头最小长度为 20 字节。
```
***
|Header Length|Header Length所代表的实际的IP报头长度|
|:-----|:-----|
|0101|20字节|
|0110|24字节|
|0111|28字节|
|...|...|
|1101|52字节|
|1110|56字节|
|1111|60字节|
***

* 三、服务类型(Type of Service):长度8bit,8位按位被如下定义：PPP DTRC0（更多详细信息可以参见 RFC1340 和 RFC1349）
```
PPP：前 3 位，定义包的优先级，取值越大数据越重要
000 普通（Routine）
001 优先的（Priority）
010 立即的发送（Immediate）
011 闪电式的（Flash）
100 比闪电还闪电式的（Flash Override）
101 CRI / TIC / ECP（找不到这个词的翻译）
110 网间控制（Internetwork Control）
111 网络控制（Network Control）
DTRCO：后 5 位
D 时延：0：普通，1：延迟尽量小
T 吞吐量：0：普通，1：流量尽量大
R 可靠性：0：普通，1：可靠性尽量大
M 传输成本：0：普通，1：成本尽量小
0 最后一位被保留，恒定为 0
```

***
**这里的bit和我们原来以为的1Byte=8bit的含义不一样**
* 四、IP包总长度(Total Length):长度16bit。<br>
**以字节为单位计算的 IP 包的长度（包括头部和数据）,也就是说单位为字节，1bit的话，可表示的最大十进制数为2，相当于2字节**，
所以IP包最大长度2^16-1=65535字节。<br>
所以，数据包有效载荷的大小 = IP包总长度(Total Length)-IP报头长度(Header Length)<br>
总长度必须不超过最大传送单元MTU

***
* 五、标识符（Identifier）：长度 16 bit 。该字段和 Flags 和 Fragment Offest 字段联合使用，对较大的上层数据包进行分段（fragment）操作。路由器将一个包拆分后，所有拆分开的小包被标记相同的值，以便目的端设备能够区分哪个包属于被拆分开的包的一部分。

***
* 六、标记（Flags):占3位，但目前只有2位有意义
```
标志字段中的最低位为MF（More Fragments）
                   MF=1:表示后面“还有分片”的数据报
                   MF=0:表示这已是若干数据报片中的最后一个
标志字段中间的一位记为 DF（Don’t Fragment）
                   DF=1：表明路由器不能对该上层数据包分段。如果一个上层数据包无法在不分段的情况下进行转发，
                         则路由器会丢弃该上层数据包并返回一个错误信息。
                   DF=0:容许分片
```

***
* 七、片偏移（Fragment Offset）：长度 13 bit，以 8 个八位组为单位。表示该 IP 包在该组分片包中位置，接收端靠此来组装还原 IP 包。

***
* 八、生存时间（Time to Live,TTL）：长度 8 bit，设计之初是以秒（s）为单位的，但实际以跳数为单位，建议的缺省值为 64 。
当 IP 包进行传送时，先会对该字段赋予某个特定的值。当 IP 包经过每一个沿途的路由器的时候，每个沿途的路由器会将 IP 包的 TTL 值减少 1 。
如果 TTL 减少为 0，则该 IP 包会被丢弃。这个字段可以防止由于路由环路而导致 IP 包在网络中不停被转发。

***
* 九、协议（Protocol）：长度 8 bit 。标识了上层所使用的协议。以下是比较常用的协议号：1 ICMP；2 IGMP；6 TCP；17 UDP；88 IGRP；89 OSPF 

***
* 十、10、头部校验（Header Checksum）：长度 16 bit 。用来做 IP 头部的正确性检测，但不包含数据部分。 因为每个路由器要改变 TTL 的值，所以路由器会为每个通过的数据包重新计算这个值（RFC1141 讨论了一些简化计算的策略）。

***
* 十一、起源和目标地址（Source and Destination Addresses）：这两个地址都是 32 bit 。标识了这个 IP 包的起源和目标地址。要注意除非使用 NAT，否则整个传输的过程中，这两个地址不会改变。

***
* 十二、可选项（Options）：这是一个可变长的字段。该字段属于可选项，主要用于测试，由起源设备根据需要改写。可选项目包含以下内容：
```
松散源路由（Loose source routing）：给出一连串路由器接口的 IP 地址。
IP 包必须沿着这些 IP 地址传送，但是允许在相继的两个 IP 地址之间跳过多个路由器。
严格源路由（Strict source routing）：给出一连串路由器接口的 IP 地址。IP 包必须沿着这些 IP 地址传送，
如果下一跳不在 IP 地址表中则表示发生错误。
路由记录（Record route）：当 IP 包离开每个路由器的时候记录路由器的出站接口的 IP 地址。
时间戳（Timestamps）：当 IP 包离开每个路由器的时候记录时间。
填充（Padding）：因为 IP 报头长度（Header Length）部分的单位为 32 bit，所以 IP 报头的长度必须为 32 bit 的整数倍。
因此，在可选项后面，IP 协议会填充若干个 0，以达到 32 bit 的整数倍。
```

***
# IP数据报分片例题
```
    一数据报长度为4000字节(固定首部长度20字节)。现在经过一个网络传送，但此网络能够传送的最大数据长度为1500字节。
试问应当划分为几个短些的数据报片？各数据报片的数据字段长度、片偏移字段和MF标志应为何数值？
```
***
|数据|总长度 字节|数据长度 字节|MF|片偏移|
|:-----|:-----|:-----|:-----|:-----|
|原始数据报|4000|3980|0|0|
|数据报片1|1500|1480|1|0|
|数据报片2|1500|1480|1|185|
|数据报片3|1040|1020|0|370|
***
***
![](https://github.com/Harrdy2018/Graphic-Http/blob/master/IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%88%86%E7%89%87.png)
***

***
# 查看会话
* 查看会话netstat -n
* 查看建立会话的进程netstat -nb

***
# 传输层协议和应用层协议之间的关系
* 常见的应用层协议之间的关系
* http=TCP+80
* https=TCP+443
* RDP=TCP+3389
* ftp=TCP+21
* 共享文件夹=TCP+445
* SMTP=TCP+25
* POP3=TCP+110
* telnet=TCP+23
* SQL=TCP+1433
* DNS=UDP+53

***
# 服务和应用层协议之间的关系
* 服务使用TCP或者UDP的端口侦听客户端请求
* 客户端使用IP地址定位服务器 使用目标端口定位服务
* 可以在服务器网卡上设置只开放必要的端口 实现服务器网络安全

***
# 如何在Windows上安装服务

***
# 如何查看服务器侦听的端口
* netstat -a
* netstat -an
* netstat -n查看建立的会话
* netstat -nb查看建立会话的进程
* telnet 192.168.80.100 3389测试远程计算机某个端口是否打开
* hostname查看计算机名字

***
# 如何更改服务器使用默认端口

***
# 如何设置Windows网络安全

***
# Telnet
```
    什么是Telnet?
    对于Telnet的认识，不同的人持有不同的观点，可以把Telnet当成一种通信协议，但是对于入侵者而言，Telnet只是一种远程登录的工具。
一旦入侵者与远程主机建立了Telnet连接，入侵者便可以使用目标主机上的软、硬件资源，而入侵者的本地机只相当于一个只有键盘和显示器的终端而已。
    为什么需要telnet？
　　telnet就是查看某个端口是否可访问。我们在搞开发的时候，经常要用的端口就是 8080。那么你可以启动服务器，用telnet 去查看这个端口是否可用。
　　Telnet协议是TCP/IP协议家族中的一员，是Internet远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。
在终端使用者的电脑上使用telnet程序，用它连接到服务器。终端使用者可以在telnet程序中输入命令，这些命令会在服务器上运行，
就像直接在服务器的控制台上输入一样。可以在本地就能控制服务器。要开始一个telnet会话，必须输入用户名和密码来登录服务器。
Telnet是常用的远程控制Web服务器的方法。
　  telnet用于远程登录到网络中的计算机，并以命令行的方式远程管理计算机。需要注意的是，远程机器必须启动telnet服务器，否则无法打开telnet命令。
```

***
# Mstsc
```
    Mstsc (Microsoft terminal services client)
    Mstsc还有一种说法，Microsoft Telnet Screen Control ，即“微软远程桌面控制”。
    Telnet协议是TCP/IP协议族中的一员，是Internet远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。
在终端使用者的电脑上使用telnet程序，用它连接到服务器。终端使用者可以在telnet程序中输入命令，这些命令会在服务器上运行，
就像直接在服务器的控制台上输入一样。
    视觉效果上：
    mstsc：登录后直接可以看到的是图形界面，而telnet看到的控制台，使用的命令操作。
    最简单的是登陆方式不同，TELNET 是文本方式的登陆，命令行操作，MSTSC是图象界面操作，TELNET用的是23端口。MSTSC默认是3389端口
```
